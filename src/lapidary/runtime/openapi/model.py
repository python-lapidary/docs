# generated by datamodel-codegen:
#   filename:  schema.yaml

# pylint: disable=invalid-name,no-self-argument

from __future__ import annotations

from enum import Enum
import re
import typing as ty

import pydantic

from .base import DynamicExtendableModel, ExtendableModel, cross_validate_content
from .ext import LapidaryModelType, PluginModel

__all__ = [
    'APIKeySecurityScheme',
    'AuthorizationCodeOAuthFlow',
    'Callback',
    'ClientCredentialsFlow',
    'Components',
    'Contact',
    'Discriminator',
    'Encoding',
    'Example',
    'ExternalDocumentation',
    'HTTPSecurityScheme',
    'Header',
    'ImplicitOAuthFlow',
    'In',
    'In1',
    'In2',
    'In3',
    'In4',
    'Info',
    'License',
    'Link',
    'MediaType',
    'OAuth2SecurityScheme',
    'OAuthFlows',
    'OpenApiModel',
    'OpenIdConnectSecurityScheme',
    'Operation',
    'Parameter',
    'ParameterLocation',
    'ParameterLocationItem',
    'ParameterLocationItem1',
    'ParameterLocationItem2',
    'ParameterLocationItem3',
    'PasswordOAuthFlow',
    'PathItem',
    'Paths',
    'Reference',
    'RequestBody',
    'Required',
    'Response',
    'Responses',
    'Schema',
    'SecurityRequirement',
    'SecurityScheme',
    'Server',
    'ServerVariable',
    'Style',
    'Style1',
    'Style2',
    'Style4',
    'Tag',
    'Type',
    'Type1',
    'Type2',
    'Type3',
    'Type4',
    'XML'
]


class Reference(pydantic.BaseModel):
    model_config = pydantic.ConfigDict(
        populate_by_name=True,
    )

    ref: ty.Annotated[str, pydantic.Field(alias='$ref')]


class Contact(ExtendableModel):
    name: ty.Optional[str] = None
    url: ty.Optional[str] = None
    email: ty.Optional[pydantic.EmailStr] = None


class License(ExtendableModel):
    name: str
    url: ty.Optional[str] = None


class ServerVariable(ExtendableModel):
    enum: ty.Optional[list[str]] = None
    default: str
    description: ty.Optional[str] = None


class Type(Enum):
    array = 'array'
    boolean = 'boolean'
    integer = 'integer'
    number = 'number'
    object = 'object'
    string = 'string'


class Discriminator(pydantic.BaseModel):
    propertyName: str
    mapping: ty.Optional[dict[str, str]] = None


class XML(ExtendableModel):
    name: ty.Optional[str] = None
    namespace: ty.Optional[pydantic.AnyUrl] = None
    prefix: ty.Optional[str] = None
    attribute: ty.Optional[bool] = False
    wrapped: ty.Optional[bool] = False


class Example(ExtendableModel):
    summary: ty.Optional[str] = None
    description: ty.Optional[str] = None
    value: ty.Optional[ty.Any] = None
    externalValue: ty.Optional[str] = None


class Style(Enum):
    simple = 'simple'


SecurityRequirement = pydantic.RootModel[dict[str, list[str]]]


class ExternalDocumentation(ExtendableModel):
    description: ty.Optional[str] = None
    url: str


ExampleXORExamples = pydantic.RootModel[ty.Any]


class In(Enum):
    path = 'path'


class Style1(Enum):
    matrix = 'matrix'
    label = 'label'
    simple = 'simple'


class Required(Enum):
    bool_True = True


class ParameterLocationItem(pydantic.BaseModel):
    """
    Parameter in path
    """

    in_: ty.Annotated[ty.Optional[In], pydantic.Field(alias='in')]
    style: ty.Optional[Style1] = Style1.simple
    required: Required

    model_config = pydantic.ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )


class In1(Enum):
    query = 'query'


class Style2(Enum):
    form = 'form'
    spaceDelimited = 'spaceDelimited'
    pipeDelimited = 'pipeDelimited'
    deepObject = 'deepObject'


class ParameterLocationItem1(pydantic.BaseModel):
    """
    Parameter in query
    """

    in_: ty.Annotated[ty.Optional[In1], pydantic.Field(alias='in')]
    style: ty.Optional[Style2] = Style2.form

    model_config = pydantic.ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )


class In2(Enum):
    header = 'header'


class ParameterLocationItem2(pydantic.BaseModel):
    """
    Parameter in header
    """

    in_: ty.Annotated[ty.Optional[In2], pydantic.Field(alias='in')]
    style: ty.Optional[Style] = Style.simple

    model_config = pydantic.ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )


class In3(Enum):
    cookie = 'cookie'


class Style4(Enum):
    form = 'form'


class ParameterLocationItem3(pydantic.BaseModel):
    """
    Parameter in cookie
    """

    in_: ty.Annotated[ty.Optional[In3], pydantic.Field(alias='in')]
    style: ty.Optional[Style4] = Style4.form

    model_config = pydantic.ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )


ParameterLocation = pydantic.RootModel[
    ty.Union[
        ParameterLocationItem,
        ParameterLocationItem1,
        ParameterLocationItem2,
        ParameterLocationItem3,
    ],
]
"""Parameter location"""


class Type1(Enum):
    apiKey = 'apiKey'


class In4(Enum):
    header = 'header'
    query = 'query'
    cookie = 'cookie'


class APIKeySecurityScheme(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
    )

    type: Type1
    name: str
    in_: ty.Annotated[In4, pydantic.Field(alias='in')]
    description: ty.Optional[str] = None


class Type2(Enum):
    http = 'http'


class HTTPSecurityScheme(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
    )

    scheme: str
    bearerFormat: ty.Optional[str] = None
    description: ty.Optional[str] = None
    type: Type2

    @pydantic.model_validator(mode='before')
    @staticmethod
    def validate_bearer_format(values: dict) -> dict:
        if 'bearerFormat' in values and values['scheme'].lower() != 'bearer':
            raise ValueError('bearerFormat is only allowed if "schema" is "bearer"')
        return values


class Type3(Enum):
    oauth2 = 'oauth2'


class Type4(Enum):
    openIdConnect = 'openIdConnect'


class OpenIdConnectSecurityScheme(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
    )

    type: Type4
    openIdConnectUrl: str
    description: ty.Optional[str] = None


class ImplicitOAuthFlow(pydantic.BaseModel):
    model_config = pydantic.ConfigDict(
        extra='forbid'
    )

    authorizationUrl: str
    refreshUrl: ty.Optional[str] = None
    scopes: dict[str, str]


class PasswordOAuthFlow(ExtendableModel):
    model_config = pydantic.ConfigDict(
        extra='forbid'
    )

    tokenUrl: str
    refreshUrl: ty.Optional[str] = None
    scopes: ty.Optional[dict[str, str]] = None

    plugin: ty.Annotated[ty.Optional[str], pydantic.Field(alias='x-plugin')] = None


class ClientCredentialsFlow(PasswordOAuthFlow):
    pass


class AuthorizationCodeOAuthFlow(pydantic.BaseModel):
    model_config = pydantic.ConfigDict(
        extra='forbid'
    )

    authorizationUrl: str
    tokenUrl: str
    refreshUrl: ty.Optional[str] = None
    scopes: ty.Optional[dict[str, str]] = None


class Info(ExtendableModel):
    title: str
    summary: str | None = None
    description: ty.Optional[str] = None
    termsOfService: ty.Optional[str] = None
    contact: ty.Optional[Contact] = None
    license: ty.Optional[License] = None
    version: str


class Server(ExtendableModel):
    url: str
    description: ty.Optional[str] = None
    variables: ty.Optional[dict[str, ServerVariable]] = None


class Schema(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
        # frozen=True,
    )

    title: ty.Optional[str] = None
    type: ty.Optional[Type] = None

    # type == number or type == integer
    multipleOf: ty.Annotated[ty.Optional[float], pydantic.Field(gt=0.0)] = None
    maximum: ty.Optional[float] = None
    exclusiveMaximum: ty.Optional[bool] = False
    minimum: ty.Optional[float] = None
    exclusiveMinimum: ty.Optional[bool] = False

    # type == string
    maxLength: ty.Annotated[ty.Optional[int], pydantic.Field(ge=0)] = None
    minLength: ty.Annotated[int, pydantic.Field(ge=0)] = 0
    pattern: ty.Optional[str] = None

    # type == array
    items: ty.Optional[ty.Union[Schema, Reference]] = None
    maxItems: ty.Annotated[ty.Optional[int], pydantic.Field(ge=0)] = None
    minItems: ty.Annotated[ty.Optional[int], pydantic.Field(ge=0)] = 0
    uniqueItems: ty.Optional[bool] = False

    # type == object
    maxProperties: ty.Annotated[ty.Optional[int], pydantic.Field(ge=0)] = None
    minProperties: ty.Annotated[ty.Optional[int], pydantic.Field(ge=0)] = 0
    required: ty.Annotated[ty.Optional[set[str]], pydantic.Field(min_items=1)] = None
    properties: ty.Optional[dict[str, ty.Union[Schema, Reference]]] = None
    additionalProperties: ty.Optional[ty.Union[Schema, Reference, bool]] = True

    # type == string or type = number or type == integer
    format: ty.Optional[str] = None

    enum: ty.Annotated[ty.Optional[list], pydantic.Field(min_items=1)] = None

    not_: ty.Annotated[ty.Optional[ty.Union[Schema, Reference]], pydantic.Field(alias='not')] = None
    allOf: ty.Optional[list[ty.Union[Schema, Reference]]] = None
    oneOf: ty.Optional[list[ty.Union[Schema, Reference]]] = None
    anyOf: ty.Optional[list[ty.Union[Schema, Reference]]] = None

    description: ty.Optional[str] = None
    default: ty.Optional[ty.Any] = None
    nullable: ty.Optional[bool] = False
    discriminator: ty.Optional[Discriminator] = None
    readOnly: ty.Optional[bool] = False
    writeOnly: ty.Optional[bool] = False
    example: ty.Optional[ty.Any] = None
    externalDocs: ty.Optional[ExternalDocumentation] = None
    deprecated: ty.Optional[bool] = False
    xml: ty.Optional[XML] = None

    lapidary_names: ty.Annotated[
        dict[ty.Union[str, None], ty.Any],
        pydantic.Field(
            alias='x-lapidary-names',
            default_factory=dict,
            description="Mapping of keys used in the JSON document and variable names in the generated Python code. "
                        "Applicable to enum values or object properties."
        )
    ] = None
    lapidary_name: ty.Annotated[ty.Optional[str], pydantic.Field(alias='x-lapidary-type-name')] = None
    lapidary_model_type: ty.Annotated[ty.Optional[LapidaryModelType], pydantic.Field(alias='x-lapidary-modelType')] = None


class Tag(ExtendableModel):
    name: str
    description: ty.Optional[str]
    externalDocs: ty.Optional[ExternalDocumentation]


class OAuthFlows(pydantic.BaseModel):
    model_config = pydantic.ConfigDict(
        extra='forbid'
    )

    implicit: ty.Optional[ImplicitOAuthFlow]
    password: ty.Optional[PasswordOAuthFlow]
    clientCredentials: ty.Optional[ClientCredentialsFlow]
    authorizationCode: ty.Optional[AuthorizationCodeOAuthFlow]


class Link(ExtendableModel):
    operationId: ty.Optional[str]
    operationRef: ty.Optional[str]
    parameters: ty.Optional[dict[str, ty.Any]]
    requestBody: ty.Optional[ty.Any]
    description: ty.Optional[str]
    server: ty.Optional[Server]


class OAuth2SecurityScheme(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
    )

    type: Type3
    flows: OAuthFlows
    description: ty.Optional[str]


SecurityScheme = pydantic.RootModel[ty.Union[
    APIKeySecurityScheme,
    HTTPSecurityScheme,
    OAuth2SecurityScheme,
    OpenIdConnectSecurityScheme,
]]


class OpenApiModel(ExtendableModel):
    """
    Validation schema for OpenAPI Specification 3.0.X.
    """

    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,

    )

    openapi: ty.Annotated[str, pydantic.Field(pattern='^3\\.0\\.\\d(-.+)?$')]
    info: Info
    externalDocs: ty.Optional[ExternalDocumentation] = None
    servers: ty.Annotated[list[Server], pydantic.Field(default_factory=list)]
    security: ty.Annotated[list[SecurityRequirement], pydantic.Field(default_factory=list)]
    tags: ty.Annotated[set[Tag], pydantic.Field(default_factory=set)]
    paths: Paths | None = None
    components: ty.Optional[Components] = None

    lapidary_headers_global: ty.Annotated[
        ty.Optional[ty.Union[
            dict[str, ty.Union[str, list[str]]],
            list[tuple[str, str]]
        ]],
        pydantic.Field(
            alias='x-lapidary-headers-global',
            description='Headers to add to every request.'
        )
    ] = None

    lapidary_responses_global: Responses = pydantic.Field(
        alias='x-lapidary-responses-global',
        description='Base Responses. Values in Responses declared in Operations override values in this one.',
        default_factory=dict,
    )


class Components(ExtendableModel):
    schemas: ty.Optional[dict[str, ty.Union[Schema, Reference]]] = None
    responses: ty.Optional[dict[str, ty.Union[Reference, Response]]] = None
    parameters: ty.Optional[dict[str, ty.Union[Reference, Parameter]]] = None
    examples: ty.Optional[dict[str, ty.Union[Reference, Example]]] = None
    requestBodies: ty.Optional[dict[str, ty.Union[Reference, RequestBody]]] = None
    headers: ty.Optional[dict[str, ty.Union[Reference, Header]]] = None
    securitySchemes: ty.Optional[dict[str, ty.Union[Reference, SecurityScheme]]] = None
    links: ty.Optional[dict[str, ty.Union[Reference, Link]]] = None
    callbacks: ty.Optional[dict[str, ty.Union[Reference, Callback]]] = None


class Response(ExtendableModel):
    description: str
    headers: ty.Optional[dict[str, ty.Union[Header, Reference]]] = {}
    content: ty.Optional[dict[str, MediaType]] = {}
    links: ty.Optional[dict[str, ty.Union[Link, Reference]]] = {}


class MediaType(ExtendableModel):
    model_config = pydantic.ConfigDict(
        **ExtendableModel.model_config,
        populate_by_name=True,
    )

    schema_: ty.Annotated[ty.Union[Schema, Reference, None], pydantic.Field(alias='schema')] = None
    example: ty.Optional[ty.Any] = None
    examples: ty.Optional[dict[str, ty.Union[Example, Reference]]] = None
    encoding: ty.Optional[dict[str, Encoding]] = None

    @pydantic.model_validator(mode='before')
    @staticmethod
    def validate_example_examples(values: dict) -> dict:
        if 'example' in values and 'examples' in values:
            raise ValueError('Only either example or examples is allowed')
        return values


class Header(ExtendableModel):
    description: ty.Optional[str]
    required: ty.Optional[bool] = False
    deprecated: ty.Optional[bool] = False
    allowEmptyValue: ty.Optional[bool] = False
    content: ty.Annotated[
        ty.Optional[dict[str, MediaType]], pydantic.Field(json_schema_extra={}, maxProperties=1, minProperties=1)
    ]
    style: ty.Optional[Style] = Style.simple
    explode: ty.Optional[bool]
    allowReserved: ty.Optional[bool] = False
    schema_: ty.Annotated[ty.Optional[ty.Union[Schema, Reference]], pydantic.Field(alias='schema')]
    example: ty.Optional[ty.Any]
    examples: ty.Optional[dict[str, ty.Union[Example, Reference]]]

    _validate_schema_xor_content = pydantic.model_validator(mode='before')(staticmethod(cross_validate_content))


class PathItem(ExtendableModel):
    summary: ty.Optional[str] = None
    description: ty.Optional[str] = None
    servers: ty.Annotated[list[Server], pydantic.Field(default_factory=list)]
    parameters: ty.Annotated[set[ty.Union[Parameter, Reference]], pydantic.Field(default_factory=set)]

    get: ty.Optional[Operation] = None
    put: ty.Optional[Operation] = None
    post: ty.Optional[Operation] = None
    delete: ty.Optional[Operation] = None
    options: ty.Optional[Operation] = None
    head: ty.Optional[Operation] = None
    patch: ty.Optional[Operation] = None
    trace: ty.Optional[Operation] = None


class Paths(DynamicExtendableModel[ty.Union[PathItem, Reference]]):
    @classmethod
    def _validate_key(cls, key: str) -> bool:
        return key.startswith('/')


class Callback(DynamicExtendableModel[ty.Union[PathItem, Reference]]):
    @classmethod
    def _validate_key(cls, key: str) -> bool:
        return True


class Operation(ExtendableModel):
    tags: ty.Annotated[list[str], pydantic.Field(default_factory=list)]
    summary: ty.Optional[str] = None
    description: ty.Optional[str] = None
    externalDocs: ty.Optional[ExternalDocumentation] = None
    operationId: ty.Optional[str] = None
    parameters: ty.Annotated[list[ty.Union[Parameter, Reference]], pydantic.Field(default_factory=set)]
    requestBody: ty.Optional[ty.Union[RequestBody, Reference]] = None
    responses: Responses | None = None
    callbacks: ty.Annotated[dict[str, ty.Union[Callback, Reference]], pydantic.Field(default_factory=dict)]
    deprecated: ty.Optional[bool] = False
    security: ty.Optional[list[SecurityRequirement]] = None
    servers: ty.Optional[list[Server]] = None

    paging: ty.Annotated[ty.Optional[PluginModel], pydantic.Field(alias='x-lapidary-pagingPlugin', default=None)]


class Responses(DynamicExtendableModel[ty.Union[Response, Reference]]):
    @classmethod
    def _validate_key(cls, key: str) -> bool:
        return key == 'default' or bool(re.match(r'^[1-5](?:\d\d|XX)$', key))

    @pydantic.model_validator(mode='before')
    @classmethod
    def _validate_min_properties(cls, values):  # pylint: disable=no-self-argument
        if not values:
            raise ValueError('minProperties')
        return values


class Parameter(ExtendableModel):
    model_config = pydantic.ConfigDict(
        populate_by_name=True,
        # frozen=True,
    )

    name: str
    in_: ty.Annotated[str, pydantic.Field(alias='in')]
    description: ty.Optional[str] = None
    required: bool = False
    deprecated: bool = False
    allowEmptyValue: bool = False
    content: ty.Annotated[
        dict[str, MediaType], pydantic.Field(maxProperties=1, minProperties=1, default_factory=dict)
    ]
    style: ty.Optional[str] = None
    explode: ty.Optional[bool] = None
    allowReserved: ty.Optional[bool] = False
    schema_: ty.Annotated[ty.Optional[ty.Union[Schema, Reference]], pydantic.Field(alias='schema')] = None
    example: ty.Optional[ty.Any] = None
    examples: ty.Annotated[dict[str, ty.Union[Example, Reference]], pydantic.Field(default_factory=dict)]

    lapidary_name: ty.Annotated[ty.Union[str, None], pydantic.Field(alias='x-lapidary-name')] = None

    _validate_schema_xor_content = pydantic.model_validator(mode='before')(staticmethod(cross_validate_content))

    def __hash__(self) -> int:
        return (hash(self.in_) << 3) + hash(self.name)

    @property
    def effective_name(self) -> str:
        return self.lapidary_name or self.name


class RequestBody(ExtendableModel):
    description: ty.Optional[str] = None
    content: dict[str, MediaType]
    required: ty.Optional[bool] = False


class Encoding(ExtendableModel):
    contentType: ty.Optional[str]
    headers: ty.Optional[dict[str, Header]]
    style: ty.Optional[Style2]
    explode: ty.Optional[bool]
    allowReserved: ty.Optional[bool] = False


Schema.model_rebuild()
OpenApiModel.model_rebuild()
Components.model_rebuild()
Response.model_rebuild()
MediaType.model_rebuild()
PathItem.model_rebuild()
Operation.model_rebuild()
Paths.model_rebuild()
