
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Build Web API clients with python annotations">
      
      
      
      
        <link rel="prev" href="../openapi/">
      
      
      
      <link rel="icon" href="../../logo.svg">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>JSON Schema - Lapidary</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6f8fc17f.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  <script data-goatcounter="https://lapidary.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#json-schema" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Lapidary" class="md-header__button md-logo" aria-label="Lapidary" data-md-component="logo">
      
  <img src="../../logo.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Lapidary
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              JSON Schema
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/python-lapidary/lapidary" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Lapidary" class="md-nav__button md-logo" aria-label="Lapidary" data-md-component="logo">
      
  <img src="../../logo.svg" alt="logo">

    </a>
    Lapidary
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/python-lapidary/lapidary" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lapidary
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Lapidary runtime
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Lapidary runtime
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../lapidary-runtime/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lapidary
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Usage
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../lapidary-runtime/usage/client/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Client class
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../lapidary-runtime/usage/operation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Operation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../lapidary-runtime/usage/auth/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Authentication
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Reference
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../lapidary-runtime/reference/lapidary/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lapidary Reference
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Lapidary render
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Lapidary render
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lapidary Render
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../plugins/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Plugins
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../openapi/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OpenAPI
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    JSON Schema
  </span>
  

      </a>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="json-schema">JSON Schema</h1>
<p>Representing JSON Schema as python types, aiming at producing types that can express no less values than the corresponding schema can validate.
Another goal is to keep models as backwards compatible as much as possible, when the schema changes in a compatible way.</p>
<p>The examples below use YAML notation of JSON Schema version draft-wright-json-schema-00.</p>
<p>Python examples use python 3.10 (PEP 604) type hints syntax.</p>
<h1 id="set-theory">Set theory</h1>
<p>JSON is a data format representing a limited collection of basic data types.</p>
<p>JSON Schema is language representing a set of constraints applicable to JSON, where empty schema means any JSON value, and set theory can be used to manipulate it.</p>
<p>Python model types, while able to represent the same basic types as JSON, describe what can be stored in memory, where empty model represents no data, which is the inversion of how JSON Schema describes values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>By default, object instances in python are just dictionaries with OOP syntax, but IDEs and type checking tools treat them more akin to C structs - if a field is not declared, it's not there.</p>
</div>
<p>Simplified, JSON Schemas can be transformed to python model with the following formula</p>
<p><code>python model = any JSON type - declared JSON Schema constraints</code></p>
<h1 id="type"><code>type</code></h1>
<ol>
<li>
<p>Since Schema object validates any JSON value, let's consider it a Union type:</p>
<pre><code>{}
</code></pre>
<p>=&gt;</p>
<pre><code>dict | list | float | int | str | bool
</code></pre>
</li>
</ol>
<h2 id="type-specific-constraints">Type-specific constraints</h2>
<p>Most of the constraints are type-specific (they apply only to values of a single type).</p>
<p>The exceptions are:</p>
<ul>
<li>nullable: extend types by type <code>null</code>, but only if type is specified in that schema</li>
<li>enum: only allow values specified in the list</li>
<li>numeric constraints for types <code>number</code> and <code>integer</code>, to both of which the numeric constraints apply.</li>
</ul>
<p>That means most constraints can be processed separately, which is useful when they occur together with <code>allOf</code>, <code>oneOf</code>, <code>allOf</code> and <code>not</code>.</p>
<h1 id="nullable">nullable</h1>
<ol>
<li>
<p>When <code>type</code> is present and <code>nullable</code> is <code>true</code>, the allowed types are extended with <code>null</code>. Three cases are possible</p>
<ol>
<li>
<p>any type but null</p>
<pre><code>{}
</code></pre>
</li>
<li>
<p>single type</p>
<pre><code>type: integer
</code></pre>
<p>=&gt;</p>
<pre><code>int
</code></pre>
</li>
<li>
<p>single type or null</p>
<pre><code>type: integer
nullable: true
</code></pre>
<p>=&gt;</p>
<pre><code>int | None
</code></pre>
</li>
</ol>
</li>
<li>
<p>Any combination of types is possible with <code>anyOf</code>/<code>oneOf</code>.</p>
<pre><code>anyOf:
-   type: string
-   type: integer
    nullable: true
</code></pre>
<p>=&gt;</p>
<pre><code>str | int | None
</code></pre>
</li>
</ol>
<h1 id="enum"><code>enum</code></h1>
<ol>
<li>
<p>If <code>enum</code> is in <code>anyOf</code> sub-schemas, the values are summed as sets.</p>
</li>
<li>
<p>If <code>enum</code> is in <code>oneOf</code> sub-schemas, only the values that occur once can be validated.</p>
</li>
</ol>
<h2 id="enum-as-literal"><code>enum</code> as <code>Literal</code></h2>
<ol>
<li>
<p>Scalar <code>enum</code> could be translated literally</p>
<pre><code>enum:
- true
- false
- FileNotFound
</code></pre>
<p>=&gt;</p>
<pre><code>Literal[True, False, 'FileNotFound']
</code></pre>
<p>or grouped by type:</p>
<pre><code>Union[
    Literal[true, False],
    StrLiteral['FileNotFound'],
]
</code></pre>
</li>
</ol>
<h2 id="enum-as-enumenum"><code>enum</code> as <code>enum.Enum</code></h2>
<ol>
<li>
<p>Both scalar and non-scalar literals could be translated as python enums, but that would require names</p>
<pre><code>type: object
enum:
- key: value
</code></pre>
<p>=&gt;</p>
<pre><code>class ${schema}Enum(Enum):
    elem${idx} = $schema(key='value')
</code></pre>
<p>This solution could introduce unintentional breaking changes when simply changing order of enum elements, unless enum elements were named with some extension keyword.</p>
<p>It would work for scalar values</p>
<pre><code>enum:
- true
- false
- FileNotFound
</code></pre>
<p>=&gt;</p>
<pre><code>class ${schema}Enum(Enum):
    value_true = True
    value_false = False
    value_FileNotFound = 'FileNotFound'
</code></pre>
</li>
</ol>
<h2 id="non-scalar-enum-values">Non-scalar enum values</h2>
<p>Non-scalar enum values don't have natural names, but a hash of stringified value could be used.</p>
<p>Also creating an arbitrary number of objects, that might never be used will be expensive and wasteful, so factory methods could be used:</p>
<pre><code class="language-yaml">enum:
-   id: 1
    name: LoL
    slug: league-of-legends
</code></pre>
<p>=&gt;</p>
<pre><code class="language-python">def value_5d9b08cdd67689d128f7c30f885f273c():
    return CurrentVideogame(
        id=1,
        name='LoL',
        slug='league-of-legends',
    )
</code></pre>
<p>The problem with this solution is that the name changes when keys or any value changes, which may or may not be desirable from the user-developer perspective.</p>
<h1 id="scalar-constraints">Scalar constraints</h1>
<ol>
<li>
<p>Constraint keywords can be grouped by type (both numeric types together) and processed as such.</p>
<pre><code>maximum: 10
maxLength: 10
anyOf:
- type: string
- type: integer
</code></pre>
<p>=&gt;</p>
<pre><code>anyOf:
- type: string
  maxLength: 10
- type: integer
  maximum: 10
</code></pre>
<p>=&gt;</p>
<pre><code>Union[
    Annotated[str, Field(max_length=10)],
    Annotated[int, Field(ge=10)]
]
</code></pre>
</li>
<li>
<p>There might be more than one element for a given type:</p>
<pre><code>anyOf:
- type: integer
  maximum: 10
- type: integer
  minimum: 20
</code></pre>
<p>=&gt;</p>
<pre><code>Union[
    Annotated[int, Field(ge=10)],
    Annotated[int, Field(le=20)],
]
</code></pre>
</li>
<li>
<p>The above is different than this, which is a bottom type (no object can validate against it, since no number can be greater than 20 <em>and</em> smaller than 10):</p>
<pre><code>type: integer
maximum: 10
minimum: 20
</code></pre>
</li>
<li>
<p>As somewhat a special case, this schema is alright:</p>
<pre><code>maximum: 10
minimum: 20
</code></pre>
<p>=&gt;</p>
<pre><code>str | bool | dict | list
</code></pre>
</li>
<li>
<p>allOf applies the most restrictive set of constraints.</p>
<pre><code>allOf:
- maximum: 10
- maximum: 20
</code></pre>
<p>=&gt;</p>
<pre><code>maximum: 10
</code></pre>
</li>
</ol>
<h1 id="object-constraints">Object constraints</h1>
<ol>
<li>
<p>JSON type <code>object</code> could be mapped to <code>dict</code> or, with some limitations to <code>TypedDict</code> or a model in one of data modelling libraries like dataclasses, pydantic msgspec, etc. Here the choice falls on pydantic, which seems the most featured.</p>
</li>
<li>
<p>In the most trivial (from python's perspective) case properties can be translated to instance fields in a model class:</p>
<pre><code>additionalProperties: false
properties:
  name:
    type: string
  required:
  - name
</code></pre>
<p>=&gt;</p>
<pre><code>class $name(BaseModel):
  name: string
</code></pre>
</li>
<li>
<p>In case of empty schema, it's impossible to say anything about it's possible contents.</p>
<p>It could be mapped as <code>dict</code> but then adding a property would cause an incompatible change in the python code. Instead, it can be translated to empty model class with <code>extra = 'allow'</code></p>
<pre><code>{}
</code></pre>
<p>=&gt;</p>
<pre><code>class $name(BaseModel):
    model_config = pydantic.ConfigDict(
        extra='allow'
    )
</code></pre>
<p>The problem with this form is that there's no way to know what to do with the extra object values.
Since an empty schema has the default:</p>
<pre><code>additionalProperties: true
</code></pre>
<p>which is the same as</p>
<pre><code>additionalProperties: {}
</code></pre>
<p>which means such a definition is indefinitely recursive. We could model it as a simple dict (in union with other types) or a common model class</p>
<pre><code>class AnyObject(BaseModel):
    model_config = pydantic.ConfigDict(
        extra='allow'
    )
</code></pre>
<p>but in either case adding a property (particularly a non-required property, which is a compatible change) leads to an incompatible change in the python model.</p>
</li>
</ol>
<h2 id="additionalproperties"><code>additionalProperties</code></h2>
<p>The value is processed as a JSON Schema.</p>
<ol>
<li>
<p><code>true</code></p>
<p>Allows extra fields of any type. See above.</p>
</li>
<li>
<p><code>false</code></p>
<p>Forbids extra fields</p>
<pre><code>class $name(BaseModel):
    model_config = pydantic.ConfigDict(
        extra='forbid'
    )
</code></pre>
</li>
<li>
<p>A schema definition.</p>
<p>Allows extra fields and, if a non-empty schema is used, generate type:</p>
<pre><code>type: object
additionalProperties:
    type: int
</code></pre>
<p>=&gt;</p>
<pre><code>class $name(BaseModel):
    model_config = pydantic.ConfigDict(
        extra='allow'
    )

    __extra__: dict[str, int]
</code></pre>
</li>
</ol>
<h2 id="writeonly-readonly-and-non-required-properties">writeOnly, readOnly and non-required properties</h2>
<p>Non-required means the same as optional in English, but <code>Optional</code> is a type in python, so avoiding it for clarity.</p>
<p><code>writeOnly</code> and <code>readOnly</code> apply to schemas that are used in other schemas' properties.
When one of the keywords is used, the property that schema describes only applies when the value is sent to or received from (respectively) the server, and should not be transferred in the other way.</p>
<p>One option to implement it would be a class hierarchy - parent class with all properties, child class for request model and one for response model. This would get complicated with nested properties.</p>
<p>Non-required properties are properties not listed in <code>required</code> list of the containing schema.</p>
<p>writeOnly, readOnly and non-required can be made optional fields in python, even though readOnly and writeOnly properties may be required.</p>
<pre><code class="language-yaml">type: object
properties:
   alpha:
      type: string
      readOnly: true
   beta:
      type: string
      writeOnly: true
   gamma:
      type: string
   required:
   -  alpha
   -  beta
</code></pre>
<p>=&gt;</p>
<pre><code class="language-python">class $name:
    alpha: str | None = None  # required in client response
    beta:  str | None = None  # required in client request
    gamma: str | None = None  # not required
</code></pre>
<h1 id="arrays"><code>array</code>s</h1>
<p>Two keywords describe arrays</p>
<h1 id="anyof"><code>anyOf</code></h1>
<p>When <code>anyOf</code> keyword is used, the instance validates as long as it validates against one of sub-schemas, while the validation results against other children schemas are ignored.</p>
<p>For example, scalar constraints can be transformed to <code>Union</code> type</p>
<pre><code>    type: integer
    oneOf:
    - maximum: 10
    - minimum: 20

=&gt;

    Union[
        Annotated[int, Field(ge=10)],
        Annotated[int, Field(le=20)],
    ]
</code></pre>
<h1 id="oneof"><code>oneOf</code></h1>
<ol>
<li>
<p>Per the specification <code>oneOf</code> keyword validates when the value validates against exactly one child schema.</p>
<p>In practice it's not the case, and <code>oneOf</code> is used as type union, typically with disjoint sub-schemas, but sometimes erroneously with overlapping ones.</p>
<p>For this reason it could be processed just like <code>anyOf</code>, although separately: values must validate against one of <code>oneOf</code> children <em>and</em> one of <code>anyOf</code> children.</p>
</li>
<li>
<p>With only <code>type</code> constraint, <code>anyOf</code> and <code>oneOf</code> are equivalent, since any value can be of only one type:</p>
<pre><code>oneOf:
- type: integer
- type: string

anyOf:
- type: integer
- type: string
</code></pre>
<p>=&gt;</p>
<pre><code>int | str
</code></pre>
</li>
<li>
<p>With more than one constraint for the same <code>type</code>, interpreting them (also for python) gets more complex</p>
<pre><code>type: integer
oneOf:
- maximum: 20
- minimum: 10
</code></pre>
<p>is equivalent to:</p>
<pre><code>type: integer
oneOf:
- allOf:
  - maximum: 20
  # not minimum: 10
  - maximum: 10
    exclusiveMaximum: true
- allOf:
  - minimum: 10
  # not maximum: 20
  - minimum: 20
    exclusiveMinimum: true
</code></pre>
<p>Since 10 &lt; 20, it reduces to:</p>
<pre><code>type: integer
oneOf:
# matches minimum: 10 but not maximum: 20
- minimum: 20
  exclusiveMinimum: true
# matches maximum: 20 but not minimum: 10
- maximum: 10
  exclusiveMaximum: true
</code></pre>
</li>
</ol>
<h1 id="allof"><code>allOf</code></h1>
<ol>
<li>
<p>When processing <code>allOf</code> in schema, the goal is generating a schema that can be directly represented as a python model.</p>
<p>The original schema must be replaced by a simplified equivalent.</p>
</li>
<li>
<p>When <code>allOf</code> keyword is used, a value must validate against the schema that contains it as well as all children schemas in <code>allOf</code>.</p>
<p>All schemas are of equal priority, and conflicting use of keywords makes it invalid for translating to a python model type.</p>
<ol>
<li>
<p>The constraints in the top schema could be pushed down under <code>allOf</code> to get a homogenous <code>allOf</code> schema:</p>
<pre><code>type: integer
allOf:
-   minimum: 10
-   multipleOf: 2
</code></pre>
<p>=&gt;</p>
<pre><code>allOf:
-   type: integer
-   minimum: 10
-   multipleOf: 2
</code></pre>
</li>
<li>
<p>Constraints in <code>allOf</code> can be also pulled up to the top schema</p>
<pre><code>allOf:
-   type: integer
-   minimum: 10
-   multipleOf: 2
</code></pre>
<p>=&gt;</p>
<pre><code>type: integer
minimum: 10
multipleOf: 2
</code></pre>
<p>Constraint keywords behave differently when used with <code>allOf</code>. For example the most restrictive constraint win in case of scalar constraints, enums use set intersection
but <code>oneOf</code> elements are deep-merged.</p>
</li>
</ol>
<p>Because it doesn't matter whether constraints are in the parent schema or pushed down to a sub-schema, the paper assumes that constraints are pushed down to simplify the language.</p>
</li>
<li>
<p>When <code>allOf</code> contains more than two sub-schemas, they can be processed sequentially</p>
<pre><code>schema1 &amp; schema2 &amp; schema3 = (schema1 &amp; schema2) &amp; schema3
</code></pre>
</li>
</ol>
<h2 id="allof-and-type"><code>allOf</code> and <code>type</code></h2>
<p><code>allOf</code> applies a set intersection to <code>type</code></p>
<pre><code># implied type: $any
allOf:
- type: integer
</code></pre>
<p>=&gt;</p>
<pre><code>type: integer
maximum: 20
</code></pre>
<p>This is a bottom type:</p>
<pre><code>allOf:
- integer
- string
</code></pre>
<h3 id="allof-and-nullable"><code>allOf</code> and <code>nullable</code></h3>
<p><code>null</code> value validates against a schema with defined <code>type</code> and <code>nullable: true</code>.</p>
<p>Since <code>nullable</code> keyword applies only when <code>type</code> is defined, the <code>nullable</code> is <code>true</code> only when the type defined in that sub-schema is included in the resulting type <em>and</em> that type is defined in every sub-schema.</p>
<pre><code class="language-yaml">allOf:
-   type: string
    nullable: true
    ...
-   type: string
    nullable: true
    ...
</code></pre>
<h2 id="allof-and-enum"><code>allOf</code> and <code>enum</code></h2>
<p>If <code>enum</code> is in <code>allOf</code> sub-schemas, the output value is a set intersection of <code>enum</code> in all sub-schemas that have one.</p>
<h2 id="allof-and-scalar-constraints"><code>allOf</code> and scalar constraints</h2>
<ol>
<li>When keywords don't repeat between sub-schemas, they can be simply merged..</li>
<li>When the same keyword is used more than once, the more constraining value wins.</li>
<li>When merging <code>maximum</code> and <code>minimum</code> values, <code>exclusiveMinimum</code> and <code>exclusiveMaximum</code> must be considered. If the keyword (<code>minmum</code> or <code>maximum</code>) has the same value, the one with <code>exclusive*: true</code> is more constraining.</li>
</ol>
<h2 id="allof-and-object-constraints"><code>allOf</code> and <code>object</code> constraints</h2>
<ol>
<li>
<p>Determining named properties:</p>
<ol>
<li>Take all property names from all sub-schemas.</li>
<li>If there are sub-schemas with <code>additionalProperties: false</code>, discard property names that match one of their property names.</li>
</ol>
</li>
<li>
<p>Determining named property schemas</p>
<p>For each named property the resulting schema is calculated by merging</p>
<ul>
<li>named property schemas from all sub-schemas with that property, and</li>
<li><code>additionalProperties</code> schemas from all sub-schemas that don't have the named property.</li>
</ul>
</li>
</ol>
<h2 id="allof-and-array-constraints"><code>allOf</code> and <code>array</code> constraints</h2>
<ol>
<li><code>additionalItems</code> is not supported in OpenAPI 3.0</li>
<li>
<p><code>items</code> schemas are merged as if they were direct children of <code>allOf</code>.</p>
<pre><code>allOf:
-   type: array
    items:
        maxLength: 10
-   type: array
    items:
        maxLength: 20
</code></pre>
<p>=&gt;</p>
<pre><code>type: array
items:
    allOf:
    -   maxLength: 10
    -   maxLength: 20
</code></pre>
<p>=&gt;</p>
<pre><code>type: array
items:
    maxLength: 10
</code></pre>
</li>
</ol>
<h2 id="nested-allof">Nested <code>allOf</code></h2>
<p>Since schemas can be pushed down and pulled up around <code>allOf</code>, sub-schemas of nested <code>allOf</code> pulled up which results in flattening the schema.</p>
<pre><code>allOf:
-   allOf:
    -   type: integer
    -   minimum: 10
-   multipleOf: 2
</code></pre>
<p>=&gt;</p>
<pre><code>allOf:
-   type: integer
-   minimum: 10
-   multipleOf: 2
</code></pre>
<h2 id="allof-and-oneof-or-anyof"><code>allOf</code> and (<code>oneOf</code> or <code>anyOf</code>)</h2>
<p>When <code>oneOf</code> and/or <code>anyOf</code> keywords are present, the validated value must match one of sub-schemas of <code>anyOf</code> <em>and</em> one of sub-schemas of <code>oneOf</code>.
A python model must be generated for each combination of constraints, meaning the schema needs to be a cartesian product of:</p>
<ul>
<li>the entire schema that's not part of <code>oneOf</code>/<code>anyOf</code></li>
<li>sub-schemas under <code>oneOf</code> of each <code>allOf</code> sub-schemas</li>
<li>sub-schemas under <code>anyOf</code> of each <code>allOf</code> sub-schemas</li>
</ul>
<h1 id="not"><code>not</code></h1>
<ol>
<li>
<p>The keyword can be interpreted as a reversal or, in some cases removal of constraints, depending on the constraint.</p>
<pre><code>not:
    minimum: 10
</code></pre>
<p>=&gt;</p>
<pre><code>maximum: 20
exclusiveMaximum: true
</code></pre>
</li>
<li>
<p>It can be used to exclude a set or a range of values:</p>
<pre><code>maximum: 65535
minimum: 1
not:
    maximum: 65534
    minimum: 65534
type: integer
</code></pre>
<p>=&gt;</p>
<pre><code>type: integer
oneOf:
-   minimum: 1
    maximum: 65535
-   minimum: 65534
    maximum: 65534
</code></pre>
<p>=&gt;</p>
<pre><code>Union[
    Annotated[int, Field(ge=1, le=65533)],
    Annotated[int, Field(ge=65535, le=65535)],
]
</code></pre>
<p>Note: this is the only use of <code>not</code> I could find in apis.guru catalogue.</p>
</li>
</ol>
<h1 id="type-and-other-keywords"><code>type</code> and other keywords</h1>
<h2 id="type-and-enum"><code>type</code> and <code>enum</code></h2>
<p>When <code>enum</code> and <code>type</code> are both used, any value present in <code>enum</code> but whose type is not present in <code>type</code> wouldn't validate.
Similarly, any value of allowed type, but absent from enum wouldn't validate.</p>
<p>Therefore <code>enum</code> keyword determines allowed types, and it's a set intersection of the two.</p>
<h2 id="nullable-types-and-enum"><code>nullable</code> types and <code>enum</code></h2>
<p>When <code>enum</code> is defined and contains a <code>null</code> value, schema must also declare <code>type</code> and <code>nullable: true</code>.</p>
<p>Otherwise <code>null</code> value doesn't validate against the default <code>type</code> or default <code>nullable</code></p>
<h2 id="type-and-constraints"><code>type</code> and constraints</h2>
<p>If <code>type</code> is defined, constraints for types not listed are discarded.</p>
<p>The default <code>type</code> value (not defined) means all types are valid and all constraints are considered.</p>
<h2 id="type-and-anyof-or-oneof"><code>type</code> and <code>anyOf</code> or <code>oneOf</code></h2>
<ol>
<li>
<p>When evaluating <code>type</code> with either <code>oneOf</code> or <code>anyOf</code>, the two are equivalent, since no JSON value can be of more than one type</p>
<pre><code>anyOf:
- type: integer
- type: string
</code></pre>
<p>or</p>
<pre><code>oneOf:
- type: integer
- type: string
</code></pre>
<p>=&gt;</p>
<pre><code>int | str
</code></pre>
</li>
</ol>
<h1 id="type-object-and-other-keywords"><code>type: object</code> and other keywords</h1>
<h2 id="object-and-oneofanyof"><code>object</code> and <code>oneOf</code>/<code>anyOf</code></h2>
<p>The properties declared directly in the schema are always present (even if nullable, but excluding <code>writeOnly</code>/<code>readOnly</code>),
but properties on <code>oneOf</code>/<code>anyOf</code> sub-schemas form optional groups, one of which must be present (even if elements of the group may be themselves optional).</p>
<p>This suggests two possible solutions:
1. Create a class for each combination of properties. When OpenAPI properties or parameters are translated to python, represent such schema as a Union type.
1. Create a class for every element of <code>anyOf</code>/<code>oneOf</code> (use cartesian product if both are present) and add a synthetic Union field in the class representing the parent schema.</p>
<p>Creating a parent class from the parent schema seems to only complicate things when both parent and sub-schemas define the same property.</p>
<ol>
<li>
<p>Creating a <code>Union</code> type</p>
<p>All constraints in the parent schema can be pushed down to <code>allOf</code>/<code>oneOf</code> so that it describes a <code>Union</code> type</p>
<pre><code>components:
    schemas:
        mySchema:
            type: object
            properties
                myProp:
                    anyOf:
                    -   type: string
                    -   $ref: '#components/schemas/mySchema'
</code></pre>
<p>=&gt;</p>
<pre><code>components:
    schemas:
        mySchema:
            type: object
            properties
                myProp:
                    anyOf:
                    -   type: string
                    -   $ref: mySchema
</code></pre>
<p>=&gt;</p>
<pre><code>class mySchema:
    myProp: str | mySchema
</code></pre>
</li>
</ol>
<h3 id="type-object-allof-and-circular-references"><code>type: object</code>, <code>allOf</code> and circular references</h3>
<p>JSON Schema specification section 7 on <code>$ref</code> warns against scenario like this:</p>
<pre><code class="language-yaml">Alice:
    properties:
        myProp1:
            type: string
    allOf:
    -   #/Bob
Bob:
    properties:
        myProp2:
            type: string
    allOf:
    -   #/Alice
</code></pre>
<p>Actually oth schemas could be represented as the same class:</p>
<pre><code class="language-python">class Schema:
    myProp1: str|None
    myProp2: str|None
</code></pre>
<p>Instance of Schema class will validate against both schemas</p>
<h3 id="type-object-oneofanyof-and-allof"><code>type: object</code>, <code>oneOf</code>/<code>anyOf</code> and <code>allOf</code></h3>
<p>Sub-schemas in <code>allOf/oneOf</code> and <code>allOf/anyOf</code> must validate separately and cannot be merged.</p>
<pre><code>type: object
properties:
    alpha:
        type: integer
additionalProperties: false
required:
-   alpha
allOf:
-   oneOf:
    -   properties:
            alpha:
                multipleOf: 2
    -   properties:
            alpha:
                multipleOf: 3
-   oneOf:
    -   properties
            alpha:
                maximum: 20
    -   properties:
            alpha:
                minimum: 10
</code></pre>
<p>Objects that validate would need validate against one of sub0schemas in the first child <em>and</em> one of sub-schemas in the second child.
In this case the object would need a <code>int</code> field named 'alpha' that can be either divisible by 2 <em>or</em> 3 and at the same time either less or equal 10 or more or equal to 20.</p>
<p>This really describes four possibilities:</p>
<ol>
<li>divisible by 2 and less or equal 20</li>
<li>divisible by 2 and more or equal 10</li>
<li>divisible by 3 and less or equal 20</li>
<li>divisible by 3 and more or equal 10</li>
</ol>
<p>We can see wee need to restructure the schema by applying cartesian product and merging the inner allOf sub-schemas:</p>
<pre><code>type: object
properties:
    alpha:
        type: integer
additionalProperties: false
required:
-   alpha
oneOf:
-   properties:
        alpha:
            multipleOf: 2
            maximum: 20
-   properties:
        alpha:
            multipleOf: 2
            minimum: 10
-   properties:
        alpha:
            multipleOf: 3
            maximum: 20
-   properties:
        alpha:
            multipleOf: 3
            minimum: 10
</code></pre>
<p>Also, properties get deep-merged:</p>
<pre><code>type: object
properties:
    alpha:
        type: integer
additionalProperties: false
required:
-   alpha
properties:
    alpha:
        oneOf:
        -   multipleOf: 2
            maximum: 20
        -   multipleOf: 2
            minimum: 10
        -   multipleOf: 3
            maximum: 20
        -   multipleOf: 3
            minimum: 10
</code></pre>
<p>Now we can see a simple python class like this:</p>
<pre><code>class $name:
    alpha: Union[
        Annotated[int, Field()]
        Annotated[int, Field()]
        Annotated[int, Field()]
        Annotated[int, Field()]
    ]
</code></pre>
<h1 id="conflicting-schemas">Conflicting schemas</h1>
<ol>
<li>
<p>There are many ways of declaring schemas that no value could validate. Such schemas aren't invalid, but the part describing a single type the the keywords apply to, must be discarded.</p>
<pre><code>minimum: 20
maximum: 10
</code></pre>
<p>=&gt;</p>
<pre><code>oneOf:
-   type: boolean
-   type: string
-   type: object
-   type: array
</code></pre>
<p>but this schema never validates, so can't be translated to a type:</p>
<pre><code>type: integer
minimum: 20
maximum: 10
</code></pre>
</li>
<li>
<p>Conflicting enum values</p>
<p><code>enum</code> keyword applies to all types so a conflict here makes the schema impossible to translate into a type:`</p>
<pre><code>allOf:
-   enum: ["red"]
-   enum: ["green"]
</code></pre>
</li>
</ol>
<h1 id="annotations">Annotations</h1>
<p>Schemas could produce annotations (type hints) and python types or type aliases (type aliases are not currently implemented).</p>
<p>Whenever a schema is <em>used</em>, in an object property, or in case of OpenAPI, operation parameter, request or response body, in python an annotation is used.</p>
<pre><code class="language-yaml">Alice:
    properties:
        bob:
            type: object
            properties:
                prop1:
                    type: str
</code></pre>
<pre><code class="language-python">
class Alice(ModelBase):
    bob: bob
</code></pre>
<p>But in order for <code>bob</code> to be valid, it also needs to be defined:</p>
<pre><code class="language-python">class bob
    prop1: str
</code></pre>
<p>Scalar schemas could produce type aliases, but currently are used inline.</p>
<pre><code class="language-yaml">Alice:
    type: object
    properties:
        prop1:
            type: integer
            maximum: 20
</code></pre>
<pre><code class="language-python">class Alice:
    prop1: Annotated[int, Le(20)]
</code></pre>
<h1 id="references">References</h1>
<ol>
<li>https://apis.guru/ - a directory of OpenAPI/swagger descriptions.</li>
<li>https://www.learnjsonschema.com/2019-09/ - an extended explanation of JSON Schema keywords. Wrong version, but close enough.</li>
</ol>









  




                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      © 2024 Rafał Krupiński
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "navigation.sections"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
    
  </body>
</html>